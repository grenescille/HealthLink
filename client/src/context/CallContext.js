import React, {
  createContext,
  useContext,
  useEffect,
  useRef,
  useState,
} from 'react';
import { io } from 'socket.io-client';
import Peer from 'simple-peer';

const CallContext = createContext();

//context will be available to all children who can have rights of access to calling data

export const CallContextProvider = ({ children }) => {
  // const socket = io('http://localhost:8080/');

  const [socket] = useState(io('http://localhost:8080/'));
  const [stream, setStream] = useState(null);
  const [me, setMe] = useState('');
  const [call, setCall] = useState({});
  const [callAccepted, setCallAccepted] = useState(false);
  const [callEnded, setCallEnded] = useState(false);
  const [name, setName] = useState('');

  const myVideo = useRef({}); //is a html video element with my video
  const userVideo = useRef({}); //is a html video element with my video
  const connectionRef = useRef({}); //need a reference outside this function for when i want to destroy the call

  //context is created so that children components at any point can access to state and inner methods

  useEffect(() => {
    navigator.mediaDevices
      .getUserMedia({
        video: true,
        audio: true,
      })
      .then((incomingStream) => {
        setStream(incomingStream);
        myVideo.current.srcObject = incomingStream;
      });

    // console.log('it starts!');

    //saves my socket.id (created by the signalling server). listening since beginning

    socket.on('ownuser', (id) => {
      // console.log('got it!');
      setMe(id);
    });

    //this particular event is received by the user that is receiving the call (callee) (with the data from the user trying to establish connection forwarded by the signalling server)
    //event 'call' originated from the signalling server
    socket.on('call', ({ senderUser, senderName, signal }) => {
      // console.log('senderId: ',senderUser,' and senderName: ',senderName);
      // console.log('signal: ',signal);
      setCall({
        //this event will be sensed by the receiver
        isReceivedCall: true,
        //caller socket.id
        from: senderUser,
        //caller name
        name: senderName,
        //signal generated by the new Peer()
        signal,
      });
    });
  }, []);

  //when we want try a call, we need to have the callee id (id)
  const callUser = (id) => {
    //when Peer() is instantiated (regardless the fact we are or not the initiator, and event 'signal' (which basically is encapsulating webrtc offers/answers and ICE candidates.. rough process difficult to bear which simple-peer helps us to abstract from))
    const callerPeer = new Peer({
      initiator: true,
      trickle: false,
      stream: stream, //my stream i need to pass to the callee
    });

    //will capture the signal originated above and emit it to the other user through the signalling server
    callerPeer.on('signal', (data) => {
      //here is where all starts
      socket.emit('call', {
        destinationUser: id,
        signallingData: data,
        from: me,
        name: name,
      });
    });

    //when communication is established and a stream from the callee is received, we need to show it on the correct video tag
    callerPeer.on('stream', (streamFromCallee) => {
      userVideo.current.srcObject = streamFromCallee;
    });

    //as a caller, we expect to receive an answer, when positive answer comes, then we will try to establish a connection
    socket.on('callaccepted', (signal) => {
      // console.log('acceptance received');
      // console.log('at caller signal: ',signal);
      setCallAccepted(true); //for conditional rendering.. if accepted than we will show callee window
      callerPeer.signal(signal); //final handshaking is done here. Trying p2p connection
    });
    //need a reference outside this function for when i want to destroy the call
    connectionRef.current = callerPeer;
  };

  const answerCall = () => {
    setCallAccepted(true);

    const calleePeer = new Peer({
      initiator: false,
      trickle: false,
      stream: stream, //my stream i need to pass to the callee
    });

    // console.log('answer call');
    // console.log('callerId: ',call.from);
    // console.log('signal: ', call.signal);

    calleePeer.on('signal', (data) => {
      //here is where the answer starts (signalling process.. only after caller receive the signalling data from callee, will attempt to establish p2p connection)
      // console.log('answer. callerId:',call.from);
      // console.log('signal data: ',data);
      socket.emit('answer', { signaldata: data, callerId: call.from });
    });

    calleePeer.on('stream', (streamFromCaller) => {
      //the other user video, from the point of view of the callee (who is answering the call, is the userVideo and not myVideo)
      userVideo.current.srcObject = streamFromCaller;
    });

    //callee attempts to establish p2p connection with caller.. only will be achieved after caller received the signalling data sent on line 92 via websockets
    calleePeer.signal(call.signal);

    //need a reference outside this function for when i want to destroy the call
    connectionRef.current = calleePeer;
  };

  const endCall = () => {
    // console.log('call ended!');
    setCallEnded(true);

    connectionRef.current.destroy();

    //reloads the page and a new socket.id is generated and handover to the client in the useEffect() (which will be re-runned). This is done due to some issues when we want to start immediatly a new call with same socket
    window.location.reload();
  };

  return (
    <CallContext.Provider
      value={{
        call,
        callAccepted,
        callEnded,
        myVideo,
        userVideo,
        stream,
        name,
        setName,
        me,
        callUser,
        endCall,
        answerCall,
      }}
    >
      {children}
    </CallContext.Provider>
  );
};

//Custom hook
export const useCall = () => {
  return useContext(CallContext);
};
